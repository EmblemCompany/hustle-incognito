<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hustle Incognito + Emblem Auth Demo</title>
  <link rel="stylesheet" href="auth-demo-advanced.css">
  <style>
    .payg-stat-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 12px;
      font-size: 13px;
    }
    .payg-stat-item {
      padding: 8px;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
    }
    .payg-stat-item .label {
      color: #6b7280;
      font-size: 11px;
      margin-bottom: 2px;
    }
    .payg-stat-item .value {
      color: #e6eef8;
      font-weight: 500;
    }
    .payg-blocked {
      color: #ef4444;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Agent Hustle SDK</h1>
    <p class="subtitle">Advanced streaming chat demo with EmblemAuth support</p>
    <div class="demo-nav">
      <a href="auth-demo-simple.html" class="demo-nav-item">Basic</a>
      <span class="demo-nav-separator">|</span>
      <span class="demo-nav-item active">Advanced</span>
    </div>

    <!-- Authentication Section -->
    <div class="auth-section">
      <!-- Not Connected State -->
      <div id="connectContainer" class="connect-container">
        <button id="loginBtn" class="connect-btn">
          <span class="connect-icon">‚Üí</span>
          Connect
        </button>
      </div>

      <!-- Connected State -->
      <div id="connectedContainer" class="connected-container" style="display:none;">
        <div class="connected-header">
          <div class="vault-info-wrapper">
            <button id="connectedBtn" class="connected-btn">
              <span class="connected-check">‚úì</span>
              <span>Connected</span>
              <span class="connected-dot">‚Ä¢</span>
              <span id="shortAddress" class="short-address">0x0000...0000</span>
              <span class="dropdown-arrow">‚ñæ</span>
            </button>

            <div id="vaultInfo" class="vault-info">
              <div class="vault-info-header">VAULT INFORMATION</div>
              <div class="vault-info-row">
                <span class="vault-label">Vault ID</span>
                <div class="vault-value-row">
                  <span id="vaultIdDisplay" class="vault-value">#0</span>
                  <button class="copy-btn" onclick="copyToClipboard('vaultIdDisplay', this)">Copy</button>
                </div>
              </div>
              <div class="vault-info-row">
                <span class="vault-label">Connected Wallet</span>
                <div class="vault-value-row">
                  <span id="walletDisplay" class="vault-value mono">0x0000000000000000000000000000000000000000</span>
                  <button class="copy-btn" onclick="copyToClipboard('walletDisplay', this)">Copy</button>
                </div>
              </div>
            </div>
          </div>
          <button id="logoutBtn" class="logout-icon-btn" title="Disconnect">‚èª</button>
        </div>
      </div>
    </div>
    <div id="authStatus" style="display:none;"></div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal-overlay">
      <div class="modal">
        <div class="modal-header">
          <span class="modal-title">Settings</span>
          <button id="closeSettingsBtn" class="modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <!-- Model Selection -->
          <div class="setting-group">
            <label class="setting-label">Model</label>
            <p class="setting-description">Select the AI model to use for chat responses</p>
            <select id="modelSelect" class="setting-select">
              <option value="">Default (server decides)</option>
            </select>
            <div id="modelInfo" class="model-info"></div>
          </div>

          <!-- Skip Server System Prompt -->
          <div class="setting-group">
            <label class="setting-label">Server System Prompt</label>
            <div class="setting-toggle">
              <span class="toggle-label">Skip server-provided system prompt</span>
              <label class="toggle-switch">
                <input type="checkbox" id="skipServerPromptToggle">
                <span class="toggle-slider"></span>
              </label>
            </div>
            <p class="setting-description" style="margin-top: 8px;">When enabled, the server's default system prompt will not be used</p>
          </div>

          <!-- Custom System Prompt -->
          <div class="setting-group">
            <label class="setting-label">Custom System Prompt</label>
            <p class="setting-description">Provide instructions for how the AI should behave</p>
            <textarea id="systemPromptModal" class="setting-textarea" placeholder="You are a helpful assistant..."></textarea>
          </div>

          <!-- Divider -->
          <div class="setting-divider"></div>

          <!-- PAYG Billing -->
          <div class="setting-group">
            <label class="setting-label">Pay-As-You-Go Billing</label>
            <p class="setting-description">Manage your PAYG billing configuration</p>
            <div id="paygSection">
              <p class="setting-description" style="font-style: italic;">Loading billing status...</p>
            </div>
          </div>

          <!-- Divider -->
          <div class="setting-divider"></div>

          <!-- Plugins Section -->
          <div class="setting-group">
            <label class="setting-label">Plugins</label>
            <p class="setting-description">Extend the AI with custom tools</p>

            <!-- Installed plugins -->
            <div id="pluginList" class="plugin-list">
              <div class="plugin-empty">No plugins installed</div>
            </div>

            <!-- Available plugins -->
            <div id="availablePluginsSection" style="display:none;">
              <div class="available-plugins-header">Available</div>
              <div id="availablePluginList" class="plugin-list"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <pre id="sessionInfo" style="display:none;">No active session</pre>

    <!-- Chat Modal (multi-purpose) -->
    <div id="chatModal" class="modal-overlay">
      <div class="modal">
        <div class="modal-header">
          <span id="chatModalTitle" class="modal-title">Save Chat</span>
          <button id="closeChatModal" class="modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <p id="chatModalDesc" class="setting-description" style="margin-bottom: 16px;">Enter a name for this chat:</p>
          <div id="chatModalCurrentName" style="display:none; margin-bottom: 12px;">
            <span style="font-size: 12px; color: #6b7280;">Current name:</span>
            <span id="chatModalCurrentNameValue" style="font-size: 14px; color: #e6eef8; font-weight: 500; margin-left: 8px;"></span>
          </div>
          <div id="chatModalInputGroup" style="margin-bottom: 16px;">
            <input type="text" id="chatModalInput" class="modal-input" placeholder="My Chat..." style="margin-bottom: 0;">
          </div>
          <div class="modal-actions">
            <button id="chatModalCancelBtn" class="modal-btn modal-btn-secondary">Cancel</button>
            <button id="chatModalDiscardBtn" class="modal-btn modal-btn-danger" style="display:none;">Discard</button>
            <button id="chatModalDeleteBtn" class="modal-btn modal-btn-danger" style="display:none;">Delete</button>
            <button id="chatModalSaveAsNewBtn" class="modal-btn modal-btn-secondary" style="display:none;">Save as New</button>
            <button id="chatModalSaveBtn" class="modal-btn modal-btn-primary">Save</button>
          </div>
        </div>
      </div>
    </div>
  </div><!-- End container -->

    <!-- Chat Layout with Sidebar -->
    <div class="chat-layout-wrapper">
      <div class="chat-layout">
        <button id="sidebarOpenBtn" class="sidebar-open-btn hidden" title="Show saved chats">‚ò∞</button>
        <!-- Sidebar with Saved Chats -->
        <div id="sidebar" class="sidebar collapsed">
          <div class="sidebar-header">
            <span class="sidebar-title">Saved Chats</span>
            <button id="sidebarCloseBtn" class="sidebar-toggle" title="Hide sidebar">‚úï</button>
          </div>
          <div class="sidebar-content">
            <div id="chatListSection" class="chat-list-section">
              <div id="chatList" class="chat-list">
                <div class="chat-list-empty">No saved chats yet</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
          <!-- Chat Card -->
          <div class="card">
      <div class="chat-header">
        <div class="chat-header-left">
          <h2>Chat</h2>
          <span id="chatNameDisplay" class="chat-name" style="display:none;"></span>
        </div>
        <button id="fullscreenBtn" class="fullscreen-btn" title="Toggle fullscreen">
          <span class="fullscreen-icon expand">‚õ∂</span>
          <span class="fullscreen-icon collapse" style="display:none;">‚õ∂</span>
        </button>
        <div class="chat-actions-wrapper">
          <span id="selectedModelLabel" class="selected-model-label"></span>
          <div class="chat-actions">
            <button id="newChatBtn" class="chat-action-btn" disabled title="New Chat">+ New</button>
            <button id="saveChatBtn" class="chat-action-btn" disabled title="Save Chat">üíæ Save</button>
            <button id="settingsBtn" class="settings-btn" title="Settings" disabled>
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
              </svg>
            </button>
          </div>
        </div>
      </div>
      <div class="chat-container">
        <div id="messages" class="messages">
          <div class="loading">Connect to start chatting...</div>
        </div>
        <div id="toolActivity" class="tool-activity"></div>
        <div class="chat-input-row">
          <div class="file-upload-area" id="uploadArea">
            <input type="file" id="fileInput" class="file-input" accept="image/*" multiple>
            <label for="fileInput" class="file-upload-btn" title="Attach images">
              <span class="file-upload-icon">üìé</span>
            </label>
            <span id="uploadStatus" class="uploading" style="display:none;"></span>
          </div>
          <div class="chat-input">
            <input type="text" id="messageInput" placeholder="Type a message..." disabled>
            <button id="sendBtn" class="btn" disabled>Send</button>
          </div>
        </div>
        <div id="uploadedFiles" class="uploaded-files"></div>
      </div>
      <div id="chatError" class="error" style="display:none;"></div>
    </div><!-- End card -->
        </div><!-- End main-content -->
      </div><!-- End chat-layout -->
    </div><!-- End chat-layout-wrapper -->

    <!-- Debug Toggle -->
    <div class="debug-toggle">
      <button id="debugToggle" class="debug-toggle-btn">
        <span class="debug-icon">‚öô</span>
        Debug
      </button>
    </div>
    <div id="debugCard" class="card" style="display:none; max-width: 900px; margin: 0 auto 20px auto;">
      <h2>Debug Log</h2>
      <pre id="debugLog">Waiting for initialization...</pre>
    </div>

    <script>
      // =========================================================================
      // DEVELOPMENT ENVIRONMENT OVERRIDES
      // =========================================================================
      // This demo is configured to use development environments.
      // For production, these overrides are NOT necessary - the SDKs use
      // production URLs by default:
      //   - HustleIncognitoClient defaults to: https://agenthustle.ai
      //   - EmblemAuthSDK apiUrl defaults to: https://api.emblemvault.ai
      //   - EmblemAuthSDK authUrl defaults to: https://auth.emblemvault.ai
      //
      // For production, simply use: new EmblemAuthSDK({ appId: 'agenthustle.ai' })
      // and new HustleIncognitoClient({ sdk: authSDK }) without URL overrides.
      // =========================================================================
      // Toggle this flag to switch between local and dev environments
      const USE_LOCAL_API = false;

      const CONFIG = USE_LOCAL_API ? {
        // ===================== LOCAL DEVELOPMENT =====================
        // Hustle Incognito API
        hustleApiUrl: 'https://dev.agenthustle.ai',

        // Emblem Auth SDK - pointing to LOCAL API server
        emblemAuthAppId: 'dev.agenthustle.ai',
        emblemAuthApiUrl: 'http://localhost:3001',
        emblemAuthAuthUrl: 'https://dev-auth.emblemvault.ai',

        // Enable SDK debug logging
        debug: true,
      } : {
        // ===================== DEV ENVIRONMENT =====================
        // Hustle Incognito API (default: https://agenthustle.ai)
        hustleApiUrl: 'https://dev.agenthustle.ai',

        // Emblem Auth SDK (defaults: api.emblemvault.ai, auth.emblemvault.ai)
        emblemAuthAppId: 'dev.agenthustle.ai',
        emblemAuthApiUrl: 'https://dev-api.emblemvault.ai',
        emblemAuthAuthUrl: 'https://dev-auth.emblemvault.ai',

        // Enable SDK debug logging (set to false for production)
        debug: false,
      };
      // =========================================================================
    </script>

  <!-- Load Marked.js for markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- Load Emblem Auth SDK from CDN -->
  <script src="https://unpkg.com/@emblemvault/auth-sdk@latest/dist/emblem-auth.min.js"></script>

  <!-- Load Hustle Incognito -->
  <script type="module">
    import { HustleIncognitoClient } from '../dist/browser/hustle-incognito.esm.js';
    // Alternatively import hustle incognito from cdn
    // import { HustleIncognitoClient } from 'https://unpkg.com/hustle-incognito@latest/dist/browser/hustle-incognito.esm.js';

    // Make it available globally for debugging
    window.HustleIncognitoClient = HustleIncognitoClient;

    // State
    let authSDK = null;
    let hustleClient = null;
    let messages = [];
    let uploadedAttachments = [];
    let availableModels = [];
    let lastIntentContext = null; // For auto-tools mode context persistence
    let settings = {
      model: '',
      skipServerPrompt: false,
      systemPrompt: ''
    };

    // =========================================================================
    // Plugin Registry - localStorage persistence for plugins
    // =========================================================================
    const PLUGINS_STORAGE_KEY = 'hustle_demo_plugins';
    const PLUGINS_ENABLED_KEY = 'hustle_demo_plugins_enabled';

    const pluginRegistry = {
      // Load installed plugins from storage
      loadPlugins() {
        try {
          const stored = localStorage.getItem(PLUGINS_STORAGE_KEY);
          return stored ? JSON.parse(stored) : [];
        } catch (e) {
          return [];
        }
      },

      // Load enabled state for plugins
      loadEnabledState() {
        try {
          const stored = localStorage.getItem(PLUGINS_ENABLED_KEY);
          return stored ? JSON.parse(stored) : {};
        } catch (e) {
          return {};
        }
      },

      // Save plugins to storage
      savePlugins(plugins) {
        localStorage.setItem(PLUGINS_STORAGE_KEY, JSON.stringify(plugins));
      },

      // Save enabled state
      saveEnabledState(state) {
        localStorage.setItem(PLUGINS_ENABLED_KEY, JSON.stringify(state));
      },

      // Register a new plugin
      register(plugin) {
        const plugins = this.loadPlugins();
        const existingIndex = plugins.findIndex(p => p.name === plugin.name);

        // Serialize plugin for storage (convert functions to strings)
        const serialized = this.serializePlugin(plugin);

        if (existingIndex >= 0) {
          plugins[existingIndex] = serialized;
        } else {
          plugins.push(serialized);
        }

        this.savePlugins(plugins);

        // Enable by default
        const enabledState = this.loadEnabledState();
        enabledState[plugin.name] = true;
        this.saveEnabledState(enabledState);

        log('Plugin registered: ' + plugin.name);
      },

      // Unregister a plugin
      unregister(pluginName) {
        const plugins = this.loadPlugins().filter(p => p.name !== pluginName);
        this.savePlugins(plugins);

        const enabledState = this.loadEnabledState();
        delete enabledState[pluginName];
        this.saveEnabledState(enabledState);

        log('Plugin unregistered: ' + pluginName);
      },

      // Set enabled state
      setEnabled(pluginName, enabled) {
        const enabledState = this.loadEnabledState();
        enabledState[pluginName] = enabled;
        this.saveEnabledState(enabledState);
        log('Plugin ' + pluginName + ' ' + (enabled ? 'enabled' : 'disabled'));
      },

      // Check if plugin is enabled
      isEnabled(pluginName) {
        const enabledState = this.loadEnabledState();
        return enabledState[pluginName] !== false; // Default to true
      },

      // Get all plugins with enabled state
      getPluginsWithState() {
        const plugins = this.loadPlugins();
        const enabledState = this.loadEnabledState();
        return plugins.map(p => ({
          ...p,
          enabled: enabledState[p.name] !== false
        }));
      },

      // Get enabled plugins hydrated with executable functions
      getEnabledPlugins() {
        return this.getPluginsWithState()
          .filter(p => p.enabled)
          .map(p => this.hydratePlugin(p));
      },

      // Serialize plugin for storage (convert functions to strings)
      serializePlugin(plugin) {
        const serialized = {
          name: plugin.name,
          version: plugin.version,
          description: plugin.description,
          tools: plugin.tools?.map(tool => ({
            ...tool,
            executorCode: plugin.executors?.[tool.name]
              ? plugin.executors[tool.name].toString()
              : undefined
          }))
        };

        // Serialize hooks if present
        if (plugin.hooks) {
          serialized.hooksCode = {};
          if (plugin.hooks.onRegister) {
            serialized.hooksCode.onRegister = plugin.hooks.onRegister.toString();
          }
          if (plugin.hooks.beforeRequest) {
            serialized.hooksCode.beforeRequest = plugin.hooks.beforeRequest.toString();
          }
          if (plugin.hooks.afterResponse) {
            serialized.hooksCode.afterResponse = plugin.hooks.afterResponse.toString();
          }
          if (plugin.hooks.onUnregister) {
            serialized.hooksCode.onUnregister = plugin.hooks.onUnregister.toString();
          }
        }

        return serialized;
      },

      // Hydrate plugin from storage (convert strings back to functions)
      hydratePlugin(stored) {
        const executors = {};
        if (stored.tools) {
          for (const tool of stored.tools) {
            if (tool.executorCode) {
              try {
                // eslint-disable-next-line no-eval
                executors[tool.name] = eval('(' + tool.executorCode + ')');
              } catch (e) {
                console.error('[Plugin] Failed to hydrate executor for ' + tool.name, e);
                executors[tool.name] = async () => ({ error: 'Failed to load executor' });
              }
            }
          }
        }

        // Hydrate hooks if present
        const hooks = {};
        if (stored.hooksCode) {
          if (stored.hooksCode.onRegister) {
            try {
              hooks.onRegister = eval('(' + stored.hooksCode.onRegister + ')');
            } catch (e) {
              console.error('[Plugin] Failed to hydrate onRegister hook', e);
            }
          }
          if (stored.hooksCode.beforeRequest) {
            try {
              hooks.beforeRequest = eval('(' + stored.hooksCode.beforeRequest + ')');
            } catch (e) {
              console.error('[Plugin] Failed to hydrate beforeRequest hook', e);
            }
          }
          if (stored.hooksCode.afterResponse) {
            try {
              hooks.afterResponse = eval('(' + stored.hooksCode.afterResponse + ')');
            } catch (e) {
              console.error('[Plugin] Failed to hydrate afterResponse hook', e);
            }
          }
          if (stored.hooksCode.onUnregister) {
            try {
              hooks.onUnregister = eval('(' + stored.hooksCode.onUnregister + ')');
            } catch (e) {
              console.error('[Plugin] Failed to hydrate onUnregister hook', e);
            }
          }
        }

        return {
          name: stored.name,
          version: stored.version,
          description: stored.description,
          tools: stored.tools?.map(t => ({
            name: t.name,
            description: t.description,
            parameters: t.parameters
          })),
          executors: Object.keys(executors).length > 0 ? executors : undefined,
          hooks: Object.keys(hooks).length > 0 ? hooks : undefined
        };
      }
    };

    // =========================================================================
    // Available Demo Plugins
    // =========================================================================
    const availablePlugins = [
      {
        name: 'calculator-plugin',
        version: '1.0.0',
        description: 'Perform basic math calculations',
        tools: [
          {
            name: 'calculate',
            description: 'Perform a mathematical calculation. Supports basic operations: add, subtract, multiply, divide, power, sqrt.',
            parameters: {
              type: 'object',
              properties: {
                operation: {
                  type: 'string',
                  description: 'The operation to perform: add, subtract, multiply, divide, power, sqrt',
                  enum: ['add', 'subtract', 'multiply', 'divide', 'power', 'sqrt']
                },
                a: { type: 'number', description: 'First number' },
                b: { type: 'number', description: 'Second number (not needed for sqrt)' }
              },
              required: ['operation', 'a']
            }
          }
        ],
        executors: {
          calculate: async (args) => {
            const { operation, a, b } = args;
            let result;
            switch (operation) {
              case 'add': result = a + b; break;
              case 'subtract': result = a - b; break;
              case 'multiply': result = a * b; break;
              case 'divide': result = b !== 0 ? a / b : 'Error: Division by zero'; break;
              case 'power': result = Math.pow(a, b); break;
              case 'sqrt': result = Math.sqrt(a); break;
              default: result = 'Unknown operation';
            }
            return { operation, a, b, result };
          }
        }
      },
      {
        name: 'datetime-plugin',
        version: '1.0.0',
        description: 'Get current date, time, and timezone info',
        tools: [
          {
            name: 'get_datetime',
            description: 'Get the current date and time information for the user.',
            parameters: {
              type: 'object',
              properties: {
                format: {
                  type: 'string',
                  description: 'Output format: full, date, time, iso',
                  enum: ['full', 'date', 'time', 'iso']
                },
                timezone: {
                  type: 'string',
                  description: 'Timezone to use (e.g., America/New_York, Europe/London). Defaults to user local timezone.'
                }
              }
            }
          }
        ],
        executors: {
          get_datetime: async (args) => {
            const { format = 'full', timezone } = args;
            const now = new Date();
            const options = timezone ? { timeZone: timezone } : {};

            let result = {};
            switch (format) {
              case 'date':
                result = { date: now.toLocaleDateString(undefined, options) };
                break;
              case 'time':
                result = { time: now.toLocaleTimeString(undefined, options) };
                break;
              case 'iso':
                result = { iso: now.toISOString() };
                break;
              default:
                result = {
                  date: now.toLocaleDateString(undefined, options),
                  time: now.toLocaleTimeString(undefined, options),
                  iso: now.toISOString(),
                  timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                  dayOfWeek: now.toLocaleDateString(undefined, { ...options, weekday: 'long' }),
                  timestamp: now.getTime()
                };
            }
            return result;
          }
        }
      },
      {
        name: 'random-plugin',
        version: '1.0.0',
        description: 'Generate random numbers, UUIDs, and make random choices',
        tools: [
          {
            name: 'random',
            description: 'Generate random values: numbers, UUIDs, or pick randomly from a list.',
            parameters: {
              type: 'object',
              properties: {
                type: {
                  type: 'string',
                  description: 'Type of random value: number, uuid, choice, dice',
                  enum: ['number', 'uuid', 'choice', 'dice']
                },
                min: { type: 'number', description: 'Minimum value for random number (default: 0)' },
                max: { type: 'number', description: 'Maximum value for random number (default: 100)' },
                choices: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Array of choices to pick from (for choice type)'
                },
                sides: { type: 'number', description: 'Number of sides on the dice (default: 6)' },
                count: { type: 'number', description: 'Number of dice to roll (default: 1)' }
              },
              required: ['type']
            }
          }
        ],
        executors: {
          random: async (args) => {
            const { type, min = 0, max = 100, choices, sides = 6, count = 1 } = args;
            switch (type) {
              case 'number':
                return { type: 'number', value: Math.floor(Math.random() * (max - min + 1)) + min, min, max };
              case 'uuid':
                return { type: 'uuid', value: crypto.randomUUID() };
              case 'choice':
                if (!choices || choices.length === 0) return { error: 'No choices provided' };
                return { type: 'choice', value: choices[Math.floor(Math.random() * choices.length)], from: choices };
              case 'dice':
                const rolls = Array.from({ length: count }, () => Math.floor(Math.random() * sides) + 1);
                return { type: 'dice', rolls, sides, total: rolls.reduce((a, b) => a + b, 0) };
              default:
                return { error: 'Unknown random type' };
            }
          }
        }
      },
      {
        name: 'pii-protection-plugin',
        version: '1.0.0',
        description: 'Tokenizes PII before sending to AI, restores in response',
        tools: [], // No tools - hooks only
        executors: {},
        hooks: {
          beforeRequest: (request) => {
            const tokenMap = new Map();
            let tokenCounter = 0;

            const tokenize = (text) => {
              if (typeof text !== 'string') return text;
              return text
                // SSNs: 123-45-6789
                .replace(/\b\d{3}-\d{2}-\d{4}\b/g, (match) => {
                  const token = `{{SSN_${++tokenCounter}}}`;
                  tokenMap.set(token, match);
                  return token;
                })
                // Email addresses
                .replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/gi, (match) => {
                  const token = `{{EMAIL_${++tokenCounter}}}`;
                  tokenMap.set(token, match);
                  return token;
                })
                // Phone numbers
                .replace(/\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g, (match) => {
                  const token = `{{PHONE_${++tokenCounter}}}`;
                  tokenMap.set(token, match);
                  return token;
                })
                // Credit card numbers
                .replace(/\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/g, (match) => {
                  const token = `{{CARD_${++tokenCounter}}}`;
                  tokenMap.set(token, match);
                  return token;
                });
            };

            const anonymizedMessages = request.messages.map((msg) => ({
              ...msg,
              content: tokenize(msg.content),
            }));

            // Store for response phase
            const maps = window.__piiTokenMaps || new Map();
            maps.set(request.id, tokenMap);
            window.__piiTokenMaps = maps;

            if (tokenMap.size > 0) {
              console.log(`[PII] Tokenized ${tokenMap.size} sensitive values`);
            }

            return { ...request, messages: anonymizedMessages };
          },
          afterResponse: (response) => {
            const maps = window.__piiTokenMaps;
            if (!maps) return;

            let restored = response.content;
            let restoredCount = 0;

            for (const [requestId, tokenMap] of maps) {
              for (const [token, original] of tokenMap) {
                if (restored.includes(token)) {
                  restored = restored.replaceAll(token, original);
                  restoredCount++;
                }
              }
              maps.delete(requestId);
            }

            if (restoredCount > 0) {
              response.content = restored;
              console.log(`[PII] Restored ${restoredCount} sensitive values`);
            }
          }
        }
      },
      {
        name: 'user-question-plugin',
        version: '1.0.0',
        description: 'Ask the user multiple choice questions via modal',
        tools: [
          {
            name: 'ask_user',
            description: 'Ask the user a multiple choice question and wait for their response. Use this when you need user input to proceed.',
            parameters: {
              type: 'object',
              properties: {
                question: {
                  type: 'string',
                  description: 'The question to ask the user'
                },
                choices: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Array of choices for the user to pick from (2-6 options)'
                },
                allowMultiple: {
                  type: 'boolean',
                  description: 'If true, user can select multiple choices. Default: false'
                }
              },
              required: ['question', 'choices']
            }
          }
        ],
        executors: {
          ask_user: async (args) => {
            const { question, choices, allowMultiple = false } = args;

            // Self-contained HTML escape helper
            const esc = (text) => {
              const div = document.createElement('div');
              div.textContent = text;
              return div.innerHTML;
            };

            if (!choices || choices.length < 2) {
              return { error: 'At least 2 choices are required' };
            }
            if (choices.length > 6) {
              return { error: 'Maximum 6 choices allowed' };
            }

            // Create and show modal
            return new Promise((resolve) => {
              const modal = document.createElement('div');
              modal.className = 'user-question-modal';
              modal.innerHTML = `
                <div class="user-question-content">
                  <h3 class="user-question-title">Question from AI</h3>
                  <p class="user-question-text">${esc(question)}</p>
                  <div class="user-question-choices">
                    ${choices.map((choice, i) => `
                      <label class="user-question-choice">
                        <input type="${allowMultiple ? 'checkbox' : 'radio'}"
                               name="user-choice"
                               value="${i}">
                        <span>${esc(choice)}</span>
                      </label>
                    `).join('')}
                  </div>
                  <div class="user-question-actions">
                    <button class="btn-secondary user-question-cancel">Cancel</button>
                    <button class="btn-primary user-question-submit" disabled>Submit</button>
                  </div>
                </div>
              `;

              document.body.appendChild(modal);

              const inputs = modal.querySelectorAll('input[name="user-choice"]');
              const submitBtn = modal.querySelector('.user-question-submit');
              const cancelBtn = modal.querySelector('.user-question-cancel');

              // Enable submit when selection made
              inputs.forEach(input => {
                input.addEventListener('change', () => {
                  const hasSelection = Array.from(inputs).some(i => i.checked);
                  submitBtn.disabled = !hasSelection;
                });
              });

              // Handle submit
              submitBtn.addEventListener('click', () => {
                const selected = Array.from(inputs)
                  .filter(i => i.checked)
                  .map(i => choices[parseInt(i.value)]);

                modal.remove();

                resolve({
                  question,
                  selectedChoices: selected,
                  selectedIndices: Array.from(inputs)
                    .map((i, idx) => i.checked ? idx : -1)
                    .filter(idx => idx !== -1),
                  allowMultiple,
                  answered: true
                });
              });

              // Handle cancel
              cancelBtn.addEventListener('click', () => {
                modal.remove();
                resolve({
                  question,
                  selectedChoices: [],
                  answered: false,
                  cancelled: true
                });
              });

              // Close on backdrop click
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  modal.remove();
                  resolve({
                    question,
                    selectedChoices: [],
                    answered: false,
                    cancelled: true
                  });
                }
              });
            });
          }
        }
      }
    ];

    // Chat persistence state
    let currentChatName = null; // null = unsaved/active chat
    const STORAGE_KEY_ACTIVE = 'hustle_active_chat';
    const STORAGE_KEY_SAVED = 'hustle_saved_chats';
    const STORAGE_KEY_CURRENT = 'hustle_current_chat_name';

    // Modal state
    // Modes: 'save-unsaved', 'save-named', 'new-unsaved', 'new-named', 'load-unsaved', 'delete'
    let modalMode = null;
    let modalPendingAction = null; // For load/delete: { type: 'load'|'delete', chatName: string }

    // DOM elements
    const loginBtn = document.getElementById('loginBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const authStatus = document.getElementById('authStatus');
    const sessionInfo = document.getElementById('sessionInfo');
    const connectContainer = document.getElementById('connectContainer');
    const connectedContainer = document.getElementById('connectedContainer');
    const shortAddressSpan = document.getElementById('shortAddress');
    const vaultIdDisplay = document.getElementById('vaultIdDisplay');
    const walletDisplay = document.getElementById('walletDisplay');
    const messagesDiv = document.getElementById('messages');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const chatError = document.getElementById('chatError');
    const debugLog = document.getElementById('debugLog');
    const debugToggle = document.getElementById('debugToggle');
    const debugCard = document.getElementById('debugCard');
    const fileInput = document.getElementById('fileInput');
    const uploadArea = document.getElementById('uploadArea');
    const uploadStatus = document.getElementById('uploadStatus');
    const uploadedFilesDiv = document.getElementById('uploadedFiles');
    // Settings elements
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const closeSettingsBtn = document.getElementById('closeSettingsBtn');
    const modelSelect = document.getElementById('modelSelect');
    const modelInfo = document.getElementById('modelInfo');
    const skipServerPromptToggle = document.getElementById('skipServerPromptToggle');
    const systemPromptModal = document.getElementById('systemPromptModal');
    const selectedModelLabel = document.getElementById('selectedModelLabel');
    const toolActivity = document.getElementById('toolActivity');
    // Plugin elements
    const pluginListDiv = document.getElementById('pluginList');
    const availablePluginsSection = document.getElementById('availablePluginsSection');
    const availablePluginListDiv = document.getElementById('availablePluginList');
    // Chat persistence elements
    const newChatBtn = document.getElementById('newChatBtn');
    const saveChatBtn = document.getElementById('saveChatBtn');
    const chatNameDisplay = document.getElementById('chatNameDisplay');
    const chatListSection = document.getElementById('chatListSection');
    const chatListDiv = document.getElementById('chatList');
    // Chat modal elements
    const chatModal = document.getElementById('chatModal');
    const chatModalTitle = document.getElementById('chatModalTitle');
    const chatModalDesc = document.getElementById('chatModalDesc');
    const chatModalCurrentName = document.getElementById('chatModalCurrentName');
    const chatModalCurrentNameValue = document.getElementById('chatModalCurrentNameValue');
    const chatModalInputGroup = document.getElementById('chatModalInputGroup');
    const chatModalInput = document.getElementById('chatModalInput');
    const chatModalCancelBtn = document.getElementById('chatModalCancelBtn');
    const chatModalDiscardBtn = document.getElementById('chatModalDiscardBtn');
    const chatModalDeleteBtn = document.getElementById('chatModalDeleteBtn');
    const chatModalSaveAsNewBtn = document.getElementById('chatModalSaveAsNewBtn');
    const chatModalSaveBtn = document.getElementById('chatModalSaveBtn');
    const closeChatModalBtn = document.getElementById('closeChatModal');
    // Sidebar elements
    const sidebar = document.getElementById('sidebar');
    const sidebarOpenBtn = document.getElementById('sidebarOpenBtn');
    const sidebarCloseBtn = document.getElementById('sidebarCloseBtn');
    const fullscreenBtn = document.getElementById('fullscreenBtn');

    // Tool activity tracking
    const activeTools = new Map(); // toolCallId -> element

    function addToolChip(toolCallId, toolName, args) {
      if (activeTools.has(toolCallId)) return;
      const chip = document.createElement('div');
      chip.className = 'tool-chip';

      const nameSpan = document.createElement('span');
      nameSpan.textContent = toolName;
      chip.appendChild(nameSpan);

      if (args && Object.keys(args).length > 0) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tool-tooltip';
        tooltip.textContent = JSON.stringify(args, null, 2);
        chip.appendChild(tooltip);
      }

      toolActivity.appendChild(chip);
      activeTools.set(toolCallId, chip);
    }

    function removeToolChip(toolCallId) {
      const chip = activeTools.get(toolCallId);
      if (chip) {
        chip.remove();
        activeTools.delete(toolCallId);
      }
    }

    function clearToolChips() {
      toolActivity.innerHTML = '';
      activeTools.clear();
    }

    function showToolSummary(response) {
      clearToolChips();

      const toolCount = response.toolCalls?.length || 0;
      const hasSummarizationInfo = response.pathInfo?.thresholdReached || response.pathInfo?.summary;

      // Show if we have tools OR summarization info
      if (toolCount === 0 && !hasSummarizationInfo) return;

      const summary = document.createElement('div');
      summary.className = 'tool-summary';

      // Build a map of toolCallId -> result
      const resultMap = new Map();
      (response.toolResults || []).forEach(r => {
        resultMap.set(r.toolCallId, r.result);
      });

      const reasoning = response.reasoning?.thinking || '';
      const categories = response.devToolsInfo?.qualifiedCategories || response.reasoning?.categories || [];
      const availableCount = response.devToolsInfo?.toolCount || 0;

      // Build clickable tool names
      const toolLinks = response.toolCalls.map((t, i) => {
        const name = t.toolName || 'unknown';
        return `<span class="tool-name-link" data-tool-index="${i}">${name}</span>`;
      }).join(', ');

      // Determine header text based on what info we have
      const headerText = toolCount > 0
        ? `Used ${toolCount} tool${toolCount !== 1 ? 's' : ''}`
        : 'Context Info';

      summary.innerHTML = `
        <div class="tool-summary-header">
          <span>‚ñ∏</span> ${headerText}
        </div>
        <div class="tool-summary-details">
          ${reasoning ? `<div><span class="tool-summary-label">Reasoning:</span> ${reasoning}</div>` : ''}
          ${categories.length ? `<div><span class="tool-summary-label">Categories:</span> ${categories.join(', ')}</div>` : ''}
          ${availableCount ? `<div><span class="tool-summary-label">Available:</span> ${availableCount} tools</div>` : ''}
          ${toolCount > 0 ? `<div><span class="tool-summary-label">Used:</span> ${toolLinks}</div>` : ''}
          <div class="tool-detail-container"></div>
          ${response.pathInfo?.thresholdReached ? `
            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #1f2937;">
              <span class="tool-summary-label" style="color: #f59e0b;">‚ö† Context threshold reached</span>
              <div style="margin-top: 4px;">
                Tokens: ${response.pathInfo.totalTokens}/${response.pathInfo.threshold} |
                Retain: ${response.pathInfo.messageRetentionCount} messages
              </div>
            </div>
          ` : ''}
          ${response.pathInfo?.summary ? `
            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #1f2937;">
              <span class="tool-summary-label" style="color: #10b981;">üìù Conversation Summary</span>
              <div style="margin-top: 4px; font-size: 12px; color: #9ca3af; max-height: 150px; overflow-y: auto; padding: 8px; background: #0d1117; border-radius: 4px; white-space: pre-wrap;">
                ${response.pathInfo.summary}
              </div>
              ${response.pathInfo.summaryEndIndex ? `
                <div style="margin-top: 4px; font-size: 11px; color: #6b7280;">
                  Summary covers messages up to index ${response.pathInfo.summaryEndIndex}
                </div>
              ` : ''}
            </div>
          ` : ''}
        </div>
      `;

      summary.querySelector('.tool-summary-header').addEventListener('click', () => {
        summary.classList.toggle('expanded');
        summary.querySelector('.tool-summary-header span').textContent =
          summary.classList.contains('expanded') ? '‚ñæ' : '‚ñ∏';
      });

      // Handle tool name clicks
      const detailContainer = summary.querySelector('.tool-detail-container');
      summary.querySelectorAll('.tool-name-link').forEach(link => {
        link.addEventListener('click', (e) => {
          e.stopPropagation();
          const idx = parseInt(link.dataset.toolIndex);
          const tool = response.toolCalls[idx];
          const result = resultMap.get(tool.toolCallId);

          // Toggle: if already showing this tool, hide it
          if (detailContainer.dataset.activeIndex === String(idx)) {
            detailContainer.innerHTML = '';
            detailContainer.dataset.activeIndex = '';
            return;
          }

          detailContainer.dataset.activeIndex = idx;
          detailContainer.innerHTML = `
            <div class="tool-detail">
              <div class="tool-detail-section">
                <div class="tool-detail-title">Request (${tool.toolName}):</div>
                <div class="tool-detail-content">${JSON.stringify(tool.args || {}, null, 2)}</div>
              </div>
              <div class="tool-detail-section">
                <div class="tool-detail-title">Result:</div>
                <div class="tool-detail-content">${JSON.stringify(result, null, 2)}</div>
              </div>
            </div>
          `;
        });
      });

      toolActivity.appendChild(summary);
    }

    function markToolComplete(toolCallId) {
      const chip = activeTools.get(toolCallId);
      if (chip) chip.classList.add('complete');
    }

    // =========================================================================
    // Plugin UI Functions
    // =========================================================================

    // Render the installed plugins list
    function renderPluginList() {
      const plugins = pluginRegistry.getPluginsWithState();

      if (plugins.length === 0) {
        pluginListDiv.innerHTML = '<div class="plugin-empty">No plugins installed</div>';
      } else {
        pluginListDiv.innerHTML = plugins.map(plugin => {
          const toolCount = plugin.tools?.length || 0;
          return `
            <div class="plugin-row" data-plugin-name="${escapeAttr(plugin.name)}">
              <div class="plugin-info">
                <div class="plugin-icon">${plugin.enabled ? 'üîå' : '‚ö™'}</div>
                <div class="plugin-details">
                  <span class="plugin-name">${escapeHtml(plugin.name)}</span>
                  <span class="plugin-meta">v${plugin.version} ‚Ä¢ ${toolCount} tool${toolCount !== 1 ? 's' : ''}</span>
                </div>
              </div>
              <div class="plugin-actions">
                <div class="plugin-toggle ${plugin.enabled ? 'enabled' : ''}" data-toggle-plugin="${escapeAttr(plugin.name)}">
                  <div class="plugin-toggle-knob"></div>
                </div>
                <button class="plugin-remove-btn" data-remove-plugin="${escapeAttr(plugin.name)}">Remove</button>
              </div>
            </div>
          `;
        }).join('');

        // Add event listeners for toggles and remove buttons
        pluginListDiv.querySelectorAll('.plugin-toggle').forEach(toggle => {
          toggle.addEventListener('click', () => {
            const pluginName = toggle.dataset.togglePlugin;
            const isEnabled = toggle.classList.contains('enabled');
            pluginRegistry.setEnabled(pluginName, !isEnabled);
            renderPluginList();
            syncPluginsWithClient();
          });
        });

        pluginListDiv.querySelectorAll('.plugin-remove-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const pluginName = btn.dataset.removePlugin;
            pluginRegistry.unregister(pluginName);
            renderPluginList();
            renderAvailablePlugins();
            syncPluginsWithClient();
          });
        });
      }
    }

    // Render available plugins that aren't installed
    function renderAvailablePlugins() {
      const installedNames = pluginRegistry.loadPlugins().map(p => p.name);
      const available = availablePlugins.filter(p => !installedNames.includes(p.name));

      if (available.length === 0) {
        availablePluginsSection.style.display = 'none';
      } else {
        availablePluginsSection.style.display = 'block';
        availablePluginListDiv.innerHTML = available.map(plugin => `
          <div class="plugin-row" data-plugin-name="${escapeAttr(plugin.name)}">
            <div class="plugin-info">
              <div class="plugin-icon">üì¶</div>
              <div class="plugin-details">
                <span class="plugin-name">${escapeHtml(plugin.name)}</span>
                <span class="plugin-meta">${escapeHtml(plugin.description)}</span>
              </div>
            </div>
            <button class="plugin-install-btn" data-install-plugin="${escapeAttr(plugin.name)}">+ Install</button>
          </div>
        `).join('');

        // Add event listeners for install buttons
        availablePluginListDiv.querySelectorAll('.plugin-install-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const pluginName = btn.dataset.installPlugin;
            const plugin = availablePlugins.find(p => p.name === pluginName);
            if (plugin) {
              pluginRegistry.register(plugin);
              renderPluginList();
              renderAvailablePlugins();
              syncPluginsWithClient();
            }
          });
        });
      }
    }

    // Sync enabled plugins with the hustle client
    function syncPluginsWithClient() {
      if (!hustleClient) return;

      // Clear existing plugins
      const existingPlugins = hustleClient.pluginManager?.getPluginNames() || [];
      for (const name of existingPlugins) {
        hustleClient.pluginManager.unregister(name);
      }

      // Register enabled plugins
      const enabledPlugins = pluginRegistry.getEnabledPlugins();
      for (const plugin of enabledPlugins) {
        try {
          hustleClient.use(plugin);
          log('Synced plugin: ' + plugin.name);
        } catch (e) {
          console.error('[Plugin] Failed to sync plugin:', plugin.name, e);
        }
      }

      log('Synced ' + enabledPlugins.length + ' plugin(s) with client');
    }

    // Debug logging
    function log(msg) {
      const time = new Date().toLocaleTimeString();
      debugLog.textContent = `[${time}] ${msg}\n` + debugLog.textContent;
      console.log(`[${time}]`, msg);
    }

    // Settings functions
    function openSettings() {
      settingsModal.classList.add('open');
      // Sync UI with current settings
      modelSelect.value = settings.model;
      skipServerPromptToggle.checked = settings.skipServerPrompt;
      systemPromptModal.value = settings.systemPrompt;
      updateModelInfo();
      // Render plugin lists
      renderPluginList();
      renderAvailablePlugins();
      fetchPaygStatus();
    }

    function closeSettings() {
      settingsModal.classList.remove('open');
    }

    async function loadModels() {
      if (!hustleClient) return;

      log('Loading available models...');
      modelSelect.disabled = true;

      try {
        availableModels = await hustleClient.getModels();
        log(`Loaded ${availableModels.length} models`);

        // Clear existing options except default
        modelSelect.innerHTML = '<option value="">Default (server decides)</option>';

        // Group models by provider
        const grouped = {};
        availableModels.forEach(model => {
          const [provider] = model.id.split('/');
          if (!grouped[provider]) grouped[provider] = [];
          grouped[provider].push(model);
        });

        // Add grouped options
        Object.keys(grouped).sort().forEach(provider => {
          const group = document.createElement('optgroup');
          group.label = provider.charAt(0).toUpperCase() + provider.slice(1);

          grouped[provider].forEach(model => {
            const option = document.createElement('option');
            option.value = model.id;
            option.textContent = model.name;
            group.appendChild(option);
          });

          modelSelect.appendChild(group);
        });

        // Restore saved selection
        if (settings.model) {
          modelSelect.value = settings.model;
        }

        modelSelect.disabled = false;
        updateModelInfo();
      } catch (error) {
        log('Failed to load models: ' + error.message);
        modelSelect.disabled = false;
      }
    }

    function updateModelInfo() {
      const selectedId = modelSelect.value;
      if (!selectedId) {
        modelInfo.textContent = '';
        return;
      }

      const model = availableModels.find(m => m.id === selectedId);
      if (model) {
        const contextK = Math.round(model.context_length / 1000);
        const promptCost = parseFloat(model.pricing?.prompt || 0) * 1000000;
        const completionCost = parseFloat(model.pricing?.completion || 0) * 1000000;
        modelInfo.textContent = `Context: ${contextK}K tokens | Cost: $${promptCost.toFixed(2)}/$${completionCost.toFixed(2)} per 1M tokens`;
      }
    }

    function updateModelLabel() {
      if (settings.model) {
        // Extract just the model name (e.g., "claude-sonnet-4" from "anthropic/claude-sonnet-4")
        const modelName = settings.model.split('/').pop() || settings.model;
        selectedModelLabel.textContent = modelName;
      } else {
        selectedModelLabel.textContent = '';
      }
    }

    function saveSettings() {
      settings.model = modelSelect.value;
      settings.skipServerPrompt = skipServerPromptToggle.checked;
      settings.systemPrompt = systemPromptModal.value;

      // Persist to localStorage
      localStorage.setItem('hustle_auth_demo_settings', JSON.stringify(settings));
      log('Settings saved: model=' + (settings.model || 'default') + ', skipServerPrompt=' + settings.skipServerPrompt);
      updateModelLabel();
    }

    function loadSettings() {
      const saved = localStorage.getItem('hustle_auth_demo_settings');
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          settings = { ...settings, ...parsed };
          log('Loaded settings from storage');

          // Sync UI with loaded settings
          if (settings.model) modelSelect.value = settings.model;
          skipServerPromptToggle.checked = settings.skipServerPrompt;
          if (settings.systemPrompt) systemPromptModal.value = settings.systemPrompt;
          updateModelLabel();
        } catch (e) {
          log('Failed to load settings: ' + e.message);
        }
      }
    }

    // =========================================================================
    // Chat Persistence Functions
    // =========================================================================

    // Save active (unnamed) chat to localStorage
    function saveActiveChat() {
      const data = {
        messages,
        timestamp: Date.now(),
        settings: {
          model: settings.model,
          skipServerPrompt: settings.skipServerPrompt,
          systemPrompt: settings.systemPrompt
        }
      };
      localStorage.setItem(STORAGE_KEY_ACTIVE, JSON.stringify(data));
    }

    // Load active chat from localStorage
    function loadActiveChat() {
      const saved = localStorage.getItem(STORAGE_KEY_ACTIVE);
      if (saved) {
        try {
          const data = JSON.parse(saved);
          if (data.messages && data.messages.length > 0) {
            messages = data.messages;

            // Restore settings if available (preserve global settings if chat has none)
            if (data.settings) {
              if (data.settings.model) settings.model = data.settings.model;
              if (data.settings.skipServerPrompt !== undefined) settings.skipServerPrompt = data.settings.skipServerPrompt;
              if (data.settings.systemPrompt) settings.systemPrompt = data.settings.systemPrompt;

              // Update UI to reflect loaded settings
              modelSelect.value = settings.model;
              skipServerPromptToggle.checked = settings.skipServerPrompt;
              systemPromptModal.value = settings.systemPrompt;
              updateModelLabel();
              updateModelInfo();
            }

            log('Restored active chat (' + messages.length + ' messages)');
            return true;
          }
        } catch (e) {
          log('Failed to load active chat: ' + e.message);
        }
      }
      return false;
    }

    // Clear active chat from localStorage
    function clearActiveChat() {
      localStorage.removeItem(STORAGE_KEY_ACTIVE);
    }

    // Get all saved chats
    function getSavedChats() {
      const saved = localStorage.getItem(STORAGE_KEY_SAVED);
      if (saved) {
        try {
          return JSON.parse(saved);
        } catch (e) {
          return {};
        }
      }
      return {};
    }

    // Save a named chat (includes settings)
    function saveNamedChat(name, chatMessages) {
      const chats = getSavedChats();
      chats[name] = {
        messages: chatMessages,
        timestamp: Date.now(),
        settings: {
          model: settings.model,
          skipServerPrompt: settings.skipServerPrompt,
          systemPrompt: settings.systemPrompt
        }
      };
      localStorage.setItem(STORAGE_KEY_SAVED, JSON.stringify(chats));
      log('Saved chat: ' + name);
    }

    // Load a named chat (restores settings)
    function loadNamedChat(name) {
      const chats = getSavedChats();
      if (chats[name]) {
        messages = chats[name].messages;
        currentChatName = name;
        // Persist the selection
        localStorage.setItem(STORAGE_KEY_CURRENT, name);

        // Restore settings if available (preserve global settings if chat has none)
        if (chats[name].settings) {
          if (chats[name].settings.model) settings.model = chats[name].settings.model;
          if (chats[name].settings.skipServerPrompt !== undefined) settings.skipServerPrompt = chats[name].settings.skipServerPrompt;
          if (chats[name].settings.systemPrompt) settings.systemPrompt = chats[name].settings.systemPrompt;

          // Update UI to reflect loaded settings
          modelSelect.value = settings.model;
          skipServerPromptToggle.checked = settings.skipServerPrompt;
          systemPromptModal.value = settings.systemPrompt;
          updateModelLabel();
          updateModelInfo();
        }

        updateChatNameDisplay();
        renderMessages();
        log('Loaded chat: ' + name + ' (with settings)');
        return true;
      }
      return false;
    }

    // Get the persisted current chat name
    function getPersistedChatName() {
      return localStorage.getItem(STORAGE_KEY_CURRENT);
    }

    // Clear the persisted current chat name
    function clearPersistedChatName() {
      localStorage.removeItem(STORAGE_KEY_CURRENT);
    }

    // Delete a named chat
    function deleteNamedChat(name) {
      const chats = getSavedChats();
      if (chats[name]) {
        delete chats[name];
        localStorage.setItem(STORAGE_KEY_SAVED, JSON.stringify(chats));
        log('Deleted chat: ' + name);
      }
    }

    // Update chat name display in header
    function updateChatNameDisplay() {
      if (currentChatName) {
        chatNameDisplay.textContent = currentChatName;
        chatNameDisplay.style.display = 'inline-block';
      } else {
        chatNameDisplay.style.display = 'none';
      }
    }

    // Render the saved chats list
    function renderChatList() {
      const chats = getSavedChats();
      const chatNames = Object.keys(chats).sort((a, b) => {
        // Sort by timestamp descending (most recent first)
        return (chats[b].timestamp || 0) - (chats[a].timestamp || 0);
      });

      if (chatNames.length === 0) {
        chatListDiv.innerHTML = '<div class="chat-list-empty">No saved chats yet</div>';
        return;
      }

      chatListDiv.innerHTML = chatNames.map(name => {
        const chat = chats[name];
        const msgCount = chat.messages?.length || 0;
        const isActive = name === currentChatName;
        const date = chat.timestamp ? new Date(chat.timestamp).toLocaleDateString() : '';

        return `
          <div class="chat-list-item ${isActive ? 'active' : ''}" data-chat-name="${escapeAttr(name)}">
            <div class="chat-list-item-info">
              <div class="chat-list-item-name">${escapeHtml(name)}</div>
              <div class="chat-list-item-meta">${msgCount} messages${date ? ' ‚Ä¢ ' + date : ''}</div>
            </div>
            <div class="chat-list-item-actions">
              <button class="chat-list-item-share" data-share-chat="${escapeAttr(name)}" title="Share">üîó</button>
              <button class="chat-list-item-delete" data-delete-chat="${escapeAttr(name)}" title="Delete">üóë</button>
            </div>
          </div>
        `;
      }).join('');

      // Add click handlers
      chatListDiv.querySelectorAll('.chat-list-item').forEach(item => {
        item.addEventListener('click', (e) => {
          // Don't load if clicking action buttons
          if (e.target.closest('.chat-list-item-actions')) return;
          const chatName = item.dataset.chatName;
          handleLoadChat(chatName);
        });
      });

      chatListDiv.querySelectorAll('.chat-list-item-share').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const chatName = btn.dataset.shareChat;
          handleShareChat(chatName);
        });
      });

      chatListDiv.querySelectorAll('.chat-list-item-delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const chatName = btn.dataset.deleteChat;
          handleDeleteSavedChat(chatName);
        });
      });
    }

    // Escape HTML attribute
    function escapeAttr(str) {
      return str.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }

    // Handle loading a saved chat
    function handleLoadChat(name) {
      // If current chat is unsaved with messages, show modal
      if (!currentChatName && messages.length > 0) {
        openModal('load-unsaved', { type: 'load', chatName: name });
        return;
      }

      loadNamedChat(name);
      renderChatList();
    }

    // Handle deleting a saved chat
    function handleDeleteSavedChat(name) {
      openModal('delete', { type: 'delete', chatName: name });
    }

    // Handle sharing a saved chat
    function handleShareChat(name) {
      const chats = getSavedChats();
      const chat = chats[name];
      if (!chat) {
        showError('Chat not found');
        return;
      }

      // Create share data object
      const shareData = {
        name: name,
        messages: chat.messages || [],
        settings: chat.settings || {}
      };

      // Encode to base64
      const jsonStr = JSON.stringify(shareData);
      const base64 = btoa(unescape(encodeURIComponent(jsonStr)));

      // Create share URL
      const url = new URL(window.location.href);
      url.search = ''; // Clear existing params
      url.searchParams.set('share', base64);

      // Copy to clipboard
      navigator.clipboard.writeText(url.toString()).then(() => {
        log('Share URL copied to clipboard');
        // Show brief feedback
        const btn = document.querySelector(`[data-share-chat="${CSS.escape(name)}"]`);
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = '‚úì';
          btn.classList.add('copied');
          // Show "Link copied" tooltip
          showCopyFeedback(btn);
          setTimeout(() => {
            btn.textContent = originalText;
            btn.classList.remove('copied');
          }, 2000);
        }
      }).catch(err => {
        log('Failed to copy share URL: ' + err.message);
        // Fallback: show URL in prompt
        prompt('Share URL:', url.toString());
      });
    }

    // Show copy feedback tooltip
    function showCopyFeedback(btn) {
      const feedback = document.createElement('div');
      feedback.className = 'copy-feedback';
      feedback.textContent = 'Link copied!';
      btn.parentElement.appendChild(feedback);
      setTimeout(() => feedback.remove(), 2000);
    }

    // Pending share data for conflict resolution
    let pendingShareData = null;

    // Load shared chat from URL parameter
    function loadSharedChat() {
      const urlParams = new URLSearchParams(window.location.search);
      const shareParam = urlParams.get('share');

      if (!shareParam) return false;

      try {
        // Decode base64
        const jsonStr = decodeURIComponent(escape(atob(shareParam)));
        const shareData = JSON.parse(jsonStr);

        if (!shareData.name || !shareData.messages) {
          throw new Error('Invalid share data');
        }

        log('Loading shared chat: ' + shareData.name);

        // Clear the URL parameter immediately
        const cleanUrl = new URL(window.location.href);
        cleanUrl.search = '';
        window.history.replaceState({}, '', cleanUrl.toString());

        // Check if name already exists
        const chats = getSavedChats();
        if (chats[shareData.name]) {
          // Conflict - store pending data and show modal
          pendingShareData = shareData;
          openModal('share-conflict');
          return 'conflict';
        }

        // No conflict - save directly
        saveSharedChat(shareData.name, shareData);
        return true;
      } catch (err) {
        log('Failed to load shared chat: ' + err.message);
        showError('Failed to load shared chat: Invalid share link');
        return false;
      }
    }

    // Save shared chat data
    function saveSharedChat(chatName, shareData) {
      const chats = getSavedChats();
      chats[chatName] = {
        messages: shareData.messages,
        timestamp: Date.now(),
        settings: shareData.settings || {}
      };
      localStorage.setItem(STORAGE_KEY_SAVED, JSON.stringify(chats));

      // Load it as the current chat
      currentChatName = chatName;
      messages = [...shareData.messages];
      localStorage.setItem(STORAGE_KEY_CURRENT, chatName);

      // Apply settings if present (preserve global settings if shared chat has none)
      if (shareData.settings) {
        if (shareData.settings.model) settings.model = shareData.settings.model;
        if (shareData.settings.skipServerPrompt !== undefined) settings.skipServerPrompt = shareData.settings.skipServerPrompt;
        if (shareData.settings.systemPrompt) settings.systemPrompt = shareData.settings.systemPrompt;
      }

      log('Shared chat loaded and saved as: ' + chatName);
    }

    // Handle share conflict: Override existing
    function handleShareOverride() {
      if (!pendingShareData) return;
      saveSharedChat(pendingShareData.name, pendingShareData);
      updateShareUI();
      pendingShareData = null;
      closeModal();
    }

    // Handle share conflict: Save as new
    function handleShareSaveAsNew() {
      if (!pendingShareData) return;
      const chats = getSavedChats();
      let chatName = pendingShareData.name;
      let counter = 1;
      while (chats[chatName]) {
        chatName = `${pendingShareData.name} (${counter})`;
        counter++;
      }
      saveSharedChat(chatName, pendingShareData);
      updateShareUI();
      pendingShareData = null;
      closeModal();
    }

    // Handle share conflict: Ignore
    function handleShareIgnore() {
      pendingShareData = null;
      closeModal();
    }

    // Update UI after loading shared chat
    function updateShareUI() {
      updateChatNameDisplay();
      updateModelLabel();
      modelSelect.value = settings.model;
      skipServerPromptToggle.checked = settings.skipServerPrompt;
      systemPromptModal.value = settings.systemPrompt;
      renderMessages();
      renderChatList();
      openSidebar();
    }

    // =========================================================================
    // Modal Functions
    // =========================================================================

    // Reset all modal buttons to hidden
    function resetModalButtons() {
      chatModalDiscardBtn.style.display = 'none';
      chatModalDeleteBtn.style.display = 'none';
      chatModalSaveAsNewBtn.style.display = 'none';
      chatModalCurrentName.style.display = 'none';
      chatModalInputGroup.style.display = 'block';
      chatModalInput.style.borderColor = '#333';
    }

    // Open modal with specific mode
    function openModal(mode, pendingAction = null) {
      modalMode = mode;
      modalPendingAction = pendingAction;
      resetModalButtons();

      switch (mode) {
        case 'save-unsaved':
          // Saving an unsaved chat - just need name
          chatModalTitle.textContent = 'Save Chat';
          chatModalDesc.textContent = 'Enter a name for this chat:';
          chatModalInput.value = '';
          chatModalInput.placeholder = 'My Chat...';
          chatModalSaveBtn.textContent = 'Save';
          break;

        case 'save-named':
          // Saving a named chat - show current name, allow rename or save as new
          chatModalTitle.textContent = 'Save Chat';
          chatModalDesc.textContent = 'Update this chat or save as a new chat:';
          chatModalCurrentName.style.display = 'block';
          chatModalCurrentNameValue.textContent = currentChatName;
          chatModalInput.value = currentChatName;
          chatModalInput.placeholder = 'Enter new name...';
          chatModalSaveAsNewBtn.style.display = 'inline-block';
          chatModalSaveBtn.textContent = 'Update';
          break;

        case 'new-unsaved':
          // Starting new chat when current is unsaved
          chatModalTitle.textContent = 'Save Current Chat?';
          chatModalDesc.textContent = 'You have an unsaved chat. Enter a name to save it, or discard it:';
          chatModalInput.value = '';
          chatModalInput.placeholder = 'My Chat...';
          chatModalDiscardBtn.style.display = 'inline-block';
          chatModalSaveBtn.textContent = 'Save & New';
          break;

        case 'new-named':
          // Starting new chat when current is named - offer to save changes
          chatModalTitle.textContent = 'Save Changes?';
          chatModalDesc.textContent = 'Save changes to current chat before starting a new one?';
          chatModalCurrentName.style.display = 'block';
          chatModalCurrentNameValue.textContent = currentChatName;
          chatModalInputGroup.style.display = 'none';
          chatModalDiscardBtn.style.display = 'inline-block';
          chatModalDiscardBtn.textContent = 'Don\'t Save';
          chatModalSaveBtn.textContent = 'Save & New';
          break;

        case 'load-unsaved':
          // Loading a chat when current is unsaved
          chatModalTitle.textContent = 'Save Current Chat?';
          chatModalDesc.textContent = 'You have an unsaved chat. Save it before loading "' + pendingAction.chatName + '"?';
          chatModalInput.value = '';
          chatModalInput.placeholder = 'My Chat...';
          chatModalDiscardBtn.style.display = 'inline-block';
          chatModalDiscardBtn.textContent = 'Discard';
          chatModalSaveBtn.textContent = 'Save & Load';
          break;

        case 'delete':
          // Confirm deletion
          chatModalTitle.textContent = 'Delete Chat?';
          chatModalDesc.textContent = 'Are you sure you want to delete "' + pendingAction.chatName + '"? This cannot be undone.';
          chatModalInputGroup.style.display = 'none';
          chatModalDeleteBtn.style.display = 'inline-block';
          chatModalSaveBtn.style.display = 'none';
          break;

        case 'share-conflict':
          // Shared chat name conflicts with existing
          chatModalTitle.textContent = 'Chat Already Exists';
          chatModalDesc.textContent = 'A chat named "' + pendingShareData.name + '" already exists. What would you like to do?';
          chatModalInputGroup.style.display = 'none';
          chatModalSaveBtn.textContent = 'Override';
          chatModalSaveAsNewBtn.style.display = 'inline-block';
          chatModalSaveAsNewBtn.textContent = 'Save as New';
          chatModalDiscardBtn.style.display = 'inline-block';
          chatModalDiscardBtn.textContent = 'Ignore';
          break;
      }

      chatModal.classList.add('open');
      if (chatModalInputGroup.style.display !== 'none') {
        chatModalInput.focus();
      }
    }

    // Close modal
    function closeModal() {
      chatModal.classList.remove('open');
      chatModalInput.value = '';
      modalMode = null;
      modalPendingAction = null;
      // Reset discard button text
      chatModalDiscardBtn.textContent = 'Discard';
      chatModalSaveBtn.style.display = 'inline-block';
    }

    // Handle Save button click in modal
    function handleModalSave() {
      const inputName = chatModalInput.value.trim();

      // Validate input if visible
      if (chatModalInputGroup.style.display !== 'none' && !inputName) {
        chatModalInput.style.borderColor = '#dc2626';
        return;
      }

      switch (modalMode) {
        case 'save-unsaved':
          saveNamedChat(inputName, messages);
          currentChatName = inputName;
          localStorage.setItem(STORAGE_KEY_CURRENT, inputName);
          clearActiveChat();
          updateChatNameDisplay();
          renderChatList();
          break;

        case 'save-named':
          // Update existing chat (use input name which may be same or different)
          saveNamedChat(inputName, messages);
          // If name changed, delete old one
          if (inputName !== currentChatName) {
            deleteNamedChat(currentChatName);
          }
          currentChatName = inputName;
          localStorage.setItem(STORAGE_KEY_CURRENT, inputName);
          updateChatNameDisplay();
          renderChatList();
          break;

        case 'new-unsaved':
          saveNamedChat(inputName, messages);
          clearActiveChat();
          renderChatList();
          startNewChat();
          break;

        case 'new-named':
          // Save current chat then start new
          saveNamedChat(currentChatName, messages);
          renderChatList();
          startNewChat();
          break;

        case 'load-unsaved':
          // Save current then load new
          saveNamedChat(inputName, messages);
          clearActiveChat();
          renderChatList();
          loadNamedChat(modalPendingAction.chatName);
          renderChatList();
          break;

        case 'share-conflict':
          // Override existing chat with shared one
          handleShareOverride();
          return; // handleShareOverride calls closeModal
      }

      // Open sidebar to show saved chats
      openSidebar();
      closeModal();
    }

    // Handle Save as New button click
    function handleModalSaveAsNew() {
      // Handle share-conflict case
      if (modalMode === 'share-conflict') {
        handleShareSaveAsNew();
        return;
      }

      const inputName = chatModalInput.value.trim();
      if (!inputName) {
        chatModalInput.style.borderColor = '#dc2626';
        return;
      }

      // Save as new chat (don't delete old one)
      saveNamedChat(inputName, messages);
      currentChatName = inputName;
      localStorage.setItem(STORAGE_KEY_CURRENT, inputName);
      clearActiveChat();
      updateChatNameDisplay();
      renderChatList();
      openSidebar();
      closeModal();
    }

    // Handle Discard button click
    function handleModalDiscard() {
      switch (modalMode) {
        case 'new-unsaved':
        case 'new-named':
          clearActiveChat();
          startNewChat();
          break;

        case 'load-unsaved':
          clearActiveChat();
          loadNamedChat(modalPendingAction.chatName);
          renderChatList();
          break;

        case 'share-conflict':
          // Ignore the shared chat
          handleShareIgnore();
          return;
      }
      closeModal();
    }

    // Handle Delete button click
    function handleModalDelete() {
      if (modalMode === 'delete' && modalPendingAction) {
        const chatName = modalPendingAction.chatName;
        deleteNamedChat(chatName);

        // If we deleted the currently loaded chat, start new
        if (chatName === currentChatName) {
          startNewChat();
        }

        renderChatList();
      }
      closeModal();
    }

    // Start a new chat
    function startNewChat() {
      messages = [];
      currentChatName = null;
      clearActiveChat();
      clearPersistedChatName();

      // Reset settings to defaults
      settings.model = '';
      settings.skipServerPrompt = false;
      settings.systemPrompt = '';

      // Update UI to reflect cleared settings
      modelSelect.value = '';
      skipServerPromptToggle.checked = false;
      systemPromptModal.value = '';
      updateModelLabel();

      updateChatNameDisplay();
      renderMessages();
      renderChatList();
      log('Started new chat (settings cleared)');
    }

    // Handle New button click
    function handleNewChat() {
      if (messages.length === 0) {
        // No messages, just start fresh
        startNewChat();
        return;
      }

      if (currentChatName) {
        // Named chat - ask if they want to save changes
        openModal('new-named');
      } else {
        // Unsaved messages - show save/discard modal
        openModal('new-unsaved');
      }
    }

    // Handle Save button click
    function handleSaveChat() {
      if (messages.length === 0) {
        return;
      }

      if (currentChatName) {
        // Already has a name - offer to update or save as new
        openModal('save-named');
      } else {
        // Needs a name
        openModal('save-unsaved');
      }
    }

    // Initialize Emblem Auth SDK
    function initAuth() {
      if (!window.EmblemAuth) {
        log('ERROR: EmblemAuth SDK not loaded!');
        return;
      }

      log('Initializing Emblem Auth SDK...');

      authSDK = new window.EmblemAuth.EmblemAuthSDK({
        appId: CONFIG.emblemAuthAppId,
        apiUrl: CONFIG.emblemAuthApiUrl,
        authUrl: CONFIG.emblemAuthAuthUrl,
        onSuccess: (session) => {
          log('Auth success! VaultId: ' + session.user?.vaultId);
          handleAuthSuccess(session);
        },
        onError: (error) => {
          log('Auth error: ' + error.message);
          showError(error.message);
        }
      });

      // Check for existing session
      const existingSession = authSDK.getSession();
      if (existingSession) {
        log('Found existing session');
        handleAuthSuccess(existingSession);
      } else {
        log('No existing session');
      }
    }

    // Decode JWT payload (without verification)
    function decodeJwt(token) {
      try {
        const parts = token.split('.');
        if (parts.length !== 3) return null;
        const payload = JSON.parse(atob(parts[1]));
        return payload;
      } catch (e) {
        return null;
      }
    }

    // Handle successful authentication
    // Helper to truncate address
    function truncateAddress(address) {
      if (!address || address.length < 10) return address || '';
      return `${address.slice(0, 6)}...${address.slice(-4)}`;
    }

    // Copy to clipboard helper
    window.copyToClipboard = async function(elementId, btn) {
      const element = document.getElementById(elementId);
      const text = element.textContent.replace('#', ''); // Remove # prefix from vault ID

      try {
        await navigator.clipboard.writeText(text);
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        setTimeout(() => {
          btn.textContent = 'Copy';
          btn.classList.remove('copied');
        }, 1500);
      } catch (err) {
        log('Failed to copy: ' + err.message);
      }
    };

    function handleAuthSuccess(session) {
      // Get wallet/identifier from JWT claims
      const jwtClaims = session.authToken ? decodeJwt(session.authToken) : null;
      const identifier = jwtClaims?.identifier || session.user?.identifier || '';
      const walletAddress = identifier.includes(':') ? identifier.split(':')[1] : identifier;
      const vaultId = session.user?.vaultId || '';

      // Update UI - show connected state
      connectContainer.style.display = 'none';
      connectedContainer.style.display = 'block';

      // Update vault info display
      shortAddressSpan.textContent = truncateAddress(walletAddress);
      vaultIdDisplay.textContent = `#${vaultId}`;
      walletDisplay.textContent = walletAddress;

      // Store session info for debugging
      const sessionWithClaims = {
        ...session,
        _jwtClaims: jwtClaims ? {
          iss: jwtClaims.iss,
          aud: jwtClaims.aud,
          sub: jwtClaims.sub,
          appId: jwtClaims.appId,
          identifier: jwtClaims.identifier,
          iat: jwtClaims.iat ? new Date(jwtClaims.iat * 1000).toISOString() : null,
          exp: jwtClaims.exp ? new Date(jwtClaims.exp * 1000).toISOString() : null,
          scope: jwtClaims.scope
        } : null
      };
      sessionInfo.textContent = JSON.stringify(sessionWithClaims, null, 2);

      // Create Hustle client with SDK auth
      log('Creating HustleIncognitoClient with SDK auth (experimental)...');
      hustleClient = new HustleIncognitoClient({
        sdk: authSDK,
        hustleApiUrl: CONFIG.hustleApiUrl,
        debug: CONFIG.debug,
        // Plugin security configuration
        security: {
          skipVerification: true,      // Enable signature verification
          allowTrustedBuiltins: true,   // Allow predictionMarket, alert, jsExecutor, etc. without signatures
        }
      });

      // Subscribe to tool events
      hustleClient.on('tool_start', (event) => {
        clearToolChips(); // Clear previous tool before showing new one
        addToolChip(event.toolCallId, event.toolName, event.args);
      });
      hustleClient.on('tool_end', (event) => {
        // Mark as complete but keep visible
        markToolComplete(event.toolCallId);
      });
      hustleClient.on('stream_end', (event) => {
        showToolSummary(event.response);

        // Update messages array with hook-processed content and re-render
        // (e.g., PII plugin restores tokens in afterResponse hook)
        if (event.response?.content && messages.length > 0) {
          const lastMsg = messages[messages.length - 1];
          if (lastMsg.role === 'assistant' && lastMsg.content !== event.response.content) {
            lastMsg.content = event.response.content;
            renderMessages();
          }
        }
      });

      // Sync plugins from localStorage with the client
      syncPluginsWithClient();

      // Expose test function for summarization debugging
      window.testSummarization = () => {
        console.log('=== TESTING SUMMARIZATION FLOW ===');

        // Step 1: Simulate server response with thresholdReached
        console.log('Step 1: Simulating server response with thresholdReached=true');
        const fakePathInfo1 = {
          type: 'token_usage',
          thresholdReached: true,
          messageRetentionCount: 1,
          totalTokens: 25000,
          threshold: 3000
        };

        // Manually call the internal update (for testing only)
        hustleClient['updateSummarizationState'](fakePathInfo1);
        console.log('Current state after step 1:', hustleClient.getSummarizationState());

        // Step 2: Simulate what the SDK would send on next request
        console.log('\nStep 2: Next request would include trimIndex:', hustleClient.getSummarizationState().messageRetentionCount);

        // Step 3: Simulate server response WITH summary
        console.log('\nStep 3: Simulating server response WITH summary');
        const fakePathInfo2 = {
          type: 'token_usage',
          thresholdReached: false,
          messageRetentionCount: 1,
          totalTokens: 5000,
          threshold: 3000,
          summary: 'This is a test summary of the conversation. The user discussed various topics including quantum computing, naval warfare, and religious themes.',
          summaryEndIndex: 5
        };

        hustleClient['updateSummarizationState'](fakePathInfo2);
        console.log('Current state after step 3:', hustleClient.getSummarizationState());

        console.log('\n=== TEST COMPLETE ===');
        console.log('Final state:', JSON.stringify(hustleClient.getSummarizationState(), null, 2));

        return hustleClient.getSummarizationState();
      };

      window.clearSummarizationState = () => {
        hustleClient.clearSummarizationState();
        console.log('Summarization state cleared:', hustleClient.getSummarizationState());
      };

      window.getSummarizationState = () => {
        const state = hustleClient.getSummarizationState();
        console.log('Current summarization state:', JSON.stringify(state, null, 2));
        return state;
      };

      console.log('Test functions available: testSummarization(), getSummarizationState(), clearSummarizationState()');

      // Expose plugin registry for debugging
      window.pluginRegistry = pluginRegistry;
      window.availablePlugins = availablePlugins;
      console.log('Plugin functions available: pluginRegistry, availablePlugins');

      // Enable chat and settings
      messageInput.disabled = false;
      sendBtn.disabled = false;
      settingsBtn.disabled = false;
      newChatBtn.disabled = false;
      saveChatBtn.disabled = false;

      // Check for shared chat in URL first
      const sharedChatLoaded = loadSharedChat();

      if (sharedChatLoaded === true) {
        // Shared chat was loaded successfully, update UI
        updateShareUI();
      } else if (sharedChatLoaded === 'conflict') {
        // Conflict modal is showing, still load normal UI in background
        const persistedName = getPersistedChatName();
        if (persistedName && loadNamedChat(persistedName)) {
          log('Restored named chat: ' + persistedName);
        } else if (loadActiveChat()) {
          renderMessages();
        } else {
          messagesDiv.innerHTML = '<div class="loading">Ready to chat! Type a message...</div>';
        }
      } else {
        // Try to restore previous chat session
        const persistedName = getPersistedChatName();
        if (persistedName && loadNamedChat(persistedName)) {
          // Successfully loaded the previously selected named chat
          log('Restored named chat: ' + persistedName);
        } else if (loadActiveChat()) {
          // Fall back to active (unnamed) chat
          renderMessages();
        } else {
          // No chat to restore
          messagesDiv.innerHTML = '<div class="loading">Ready to chat! Type a message...</div>';
        }
      }

      // Render saved chats list
      renderChatList();

      // Load models for settings
      loadModels();

      // Pre-fetch PAYG billing status
      fetchPaygStatus();

      log(`Connected: vault #${vaultId}, wallet ${truncateAddress(walletAddress)}`);
    }

    // Handle logout
    function handleLogout() {
      if (authSDK) {
        authSDK.logout();
      }
      hustleClient = null;

      // Reset UI to disconnected state
      connectContainer.style.display = 'flex';
      connectedContainer.style.display = 'none';

      // Reset vault info
      shortAddressSpan.textContent = '0x0000...0000';
      vaultIdDisplay.textContent = '#0';
      walletDisplay.textContent = '';
      sessionInfo.textContent = 'No active session';

      // Disable chat and settings
      messageInput.disabled = true;
      sendBtn.disabled = true;
      settingsBtn.disabled = true;
      newChatBtn.disabled = true;
      saveChatBtn.disabled = true;
      messages = [];
      currentChatName = null;
      updateChatNameDisplay();
      messagesDiv.innerHTML = '<div class="loading">Connect to start chatting...</div>';

      // Clear attachments and models on logout
      clearAttachments();
      availableModels = [];
      modelSelect.innerHTML = '<option value="">Default (server decides)</option>';

      // Hide chat list
      chatListSection.style.display = 'none';

      log('Disconnected');
    }

    // Render messages
    // Configure marked for safe rendering
    marked.setOptions({
      breaks: true,
      gfm: true
    });

    function renderMessages() {
      if (messages.length === 0) {
        messagesDiv.innerHTML = '<div class="loading">Ready to chat! Type a message...</div>';
        return;
      }

      messagesDiv.innerHTML = messages.map((m, index) => {
        // Parse markdown for assistant messages, escape HTML for user messages
        const content = m.role === 'assistant'
          ? marked.parse(m.content || '')
          : escapeHtml(m.content || '');
        const retryBtn = m.role === 'user'
          ? `<button class="message-action retry" data-index="${index}" title="Retry from here">‚Üª</button>`
          : '';
        return `
          <div class="message ${m.role}">
            <div class="message-header">
              <div class="role">${m.role}</div>
              <div class="message-actions">
                ${retryBtn}
                <button class="message-action delete" data-index="${index}" title="Delete message">‚úï</button>
              </div>
            </div>
            <div class="message-content">${content}</div>
          </div>
        `;
      }).join('');

      // Add delete handlers
      messagesDiv.querySelectorAll('.message-action.delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const index = parseInt(e.target.dataset.index, 10);
          deleteMessage(index);
        });
      });

      // Add retry handlers
      messagesDiv.querySelectorAll('.message-action.retry').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const index = parseInt(e.target.dataset.index, 10);
          retryFromMessage(index);
        });
      });

      messagesDiv.scrollTop = messagesDiv.scrollHeight;

      // Auto-save chat
      if (messages.length > 0) {
        if (currentChatName) {
          // Save to named chat
          saveNamedChat(currentChatName, messages);
        } else {
          // Save to active (unnamed) chat
          saveActiveChat();
        }
      }
    }

    // Helper to escape HTML in user messages
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Delete a message by index
    function deleteMessage(index) {
      if (index >= 0 && index < messages.length) {
        messages.splice(index, 1);
        renderMessages(); // This will also auto-save
        log('Deleted message at index ' + index);
      }
    }

    // Retry from a user message - resubmit from that point
    async function retryFromMessage(index) {
      if (index < 0 || index >= messages.length) return;
      if (messages[index].role !== 'user') return;
      if (!hustleClient) {
        showError('Please login first');
        return;
      }

      const userContent = messages[index].content;

      // Slice messages to keep only those before this user message
      messages = messages.slice(0, index);
      renderMessages();

      log('Retrying from message at index ' + index);

      // Now re-send the user message
      sendBtn.disabled = true;
      messageInput.disabled = true;

      messages.push({ role: 'user', content: userContent });
      renderMessages();

      // Add empty assistant message that we'll stream into
      messages.push({ role: 'assistant', content: '' });
      renderMessages();

      try {
        // Build chat messages for API (same pattern as sendMessage)
        const chatMessages = [];
        if (settings.systemPrompt) {
          chatMessages.push({ role: 'system', content: settings.systemPrompt });
        }
        chatMessages.push(...messages.slice(0, -1).map(m => ({ role: m.role, content: m.content })));

        // Build options
        const chatOptions = {
          messages: chatMessages,
          processChunks: true
        };

        if (settings.model) {
          chatOptions.model = settings.model;
        }

        if (settings.skipServerPrompt) {
          chatOptions.overrideSystemPrompt = true;
        }

        // Use chatStream (same as sendMessage)
        const stream = hustleClient.chatStream(chatOptions);

        let fullContent = '';

        for await (const chunk of stream) {
          if (chunk.type === 'text') {
            if (activeTools.size > 0) clearToolChips();
            fullContent += chunk.value;
            messages[messages.length - 1].content = fullContent;
            renderMessages();
          } else if (chunk.type === 'tool_call') {
            log('Tool call: ' + JSON.stringify(chunk.value).substring(0, 100));
          } else if (chunk.type === 'tool_result') {
            log('Tool result received');
          } else if (chunk.type === 'error') {
            throw new Error(chunk.value?.message || 'Stream error');
          }
        }

        if (!fullContent) {
          messages[messages.length - 1].content = '(No response)';
          renderMessages();
        }

        log('Retry complete: ' + fullContent.substring(0, 50) + '...');
      } catch (error) {
        log('Retry failed: ' + error.message);
        showError('Retry failed: ' + error.message);
        messages[messages.length - 1].content = '‚ùå Error: ' + error.message;
        renderMessages();
      } finally {
        sendBtn.disabled = false;
        messageInput.disabled = false;
        messageInput.focus();
      }
    }

    // Handle file selection and upload via SDK
    async function handleFileUpload(files) {
      if (!hustleClient) {
        showError('Please login first to upload files');
        return;
      }

      for (const file of files) {
        if (!file.type.startsWith('image/')) {
          log('Skipping non-image file: ' + file.name);
          continue;
        }

        if (file.size > 5 * 1024 * 1024) {
          showError(`File ${file.name} is too large. Maximum size is 5MB.`);
          continue;
        }

        uploadStatus.textContent = `Uploading ${file.name}...`;
        uploadStatus.style.display = 'inline';
        log('Uploading file: ' + file.name);

        try {
          // Upload using the SDK's uploadFile method (accepts File in browser)
          const attachment = await hustleClient.uploadFile(file);
          uploadedAttachments.push(attachment);
          log('Upload successful: ' + attachment.url);
          renderUploadedFiles();
        } catch (error) {
          log('Upload failed: ' + error.message);
          showError(`Failed to upload ${file.name}: ${error.message}`);
        }
      }

      uploadStatus.style.display = 'none';
      fileInput.value = '';
    }

    // Render uploaded files
    function renderUploadedFiles() {
      const count = uploadedAttachments.length;

      if (count > 0) {
        uploadArea.classList.add('has-files');
      } else {
        uploadArea.classList.remove('has-files');
      }

      uploadedFilesDiv.innerHTML = uploadedAttachments.map((attachment, index) => `
        <div class="uploaded-file">
          <img src="${attachment.url}" alt="${attachment.name}">
          <span class="uploaded-file-name">${attachment.name}</span>
          <button class="remove-file-btn" onclick="removeAttachment(${index})">x</button>
        </div>
      `).join('');
    }

    // Remove attachment
    window.removeAttachment = function(index) {
      uploadedAttachments.splice(index, 1);
      renderUploadedFiles();
      log('Removed attachment');
    };

    // Clear all attachments
    function clearAttachments() {
      uploadedAttachments = [];
      renderUploadedFiles();
    }

    // Send a chat message with streaming
    async function sendMessage() {
      const content = messageInput.value.trim();
      if (!content || !hustleClient) return;

      messageInput.value = '';
      sendBtn.disabled = true;
      messageInput.disabled = true;

      messages.push({ role: 'user', content });
      renderMessages();

      // Add empty assistant message that we'll stream into
      messages.push({ role: 'assistant', content: '' });
      renderMessages();

      log('Sending message (streaming): ' + content.substring(0, 50) + '...');

      try {
        chatError.style.display = 'none';

        // Build messages array with optional system prompt
        const chatMessages = [];

        // Add system prompt as first message if provided
        if (settings.systemPrompt) {
          chatMessages.push({ role: 'system', content: settings.systemPrompt });
        }

        // Add conversation history (excluding the empty assistant message we just added)
        chatMessages.push(...messages.slice(0, -1).map(m => ({ role: m.role, content: m.content })));

        // Use chatStream for real-time streaming
        const chatOptions = {
          messages: chatMessages,
          processChunks: true
        };

        // Auto-tools mode: pass previous intent context for sticky tool selection
        if (lastIntentContext) {
          chatOptions.intentContext = lastIntentContext;
          log('Passing intent context from previous turn');
        }

        // Add model if selected
        if (settings.model) {
          chatOptions.model = settings.model;
          log('Using model: ' + settings.model);
        }

        // Add overrideSystemPrompt if enabled
        if (settings.skipServerPrompt) {
          chatOptions.overrideSystemPrompt = true;
          log('Overriding server-provided system prompt');
        }

        // Add attachments if any
        if (uploadedAttachments.length > 0) {
          chatOptions.attachments = [...uploadedAttachments];
          log('Including ' + uploadedAttachments.length + ' attachment(s) in request');
        }

        const stream = hustleClient.chatStream(chatOptions);

        // Clear attachments after adding to request
        clearAttachments();

        let fullContent = '';

        for await (const chunk of stream) {
          if (chunk.type === 'text') {
            if (activeTools.size > 0) clearToolChips(); // Clear tool display when agent starts replying
            fullContent += chunk.value;
            // Update the last message with accumulated content
            messages[messages.length - 1].content = fullContent;
            renderMessages();
          } else if (chunk.type === 'tool_call') {
            log('Tool call: ' + JSON.stringify(chunk.value).substring(0, 100));
          } else if (chunk.type === 'tool_result') {
            log('Tool result received');
          } else if (chunk.type === 'error') {
            throw new Error(chunk.value?.message || 'Stream error');
          }
        }

        // Access the aggregated ProcessedResponse after streaming
        const processedResponse = await stream.response;
        log('ProcessedResponse: ' + JSON.stringify(processedResponse, null, 2));

        // Capture intent context for auto-tools mode (sticky tool selection)
        if (processedResponse.intentContext?.intentContext) {
          lastIntentContext = processedResponse.intentContext.intentContext;
          log('Captured intent context: ' + lastIntentContext.activeIntent);
        }

        if (!fullContent) {
          messages[messages.length - 1].content = '(No response)';
          renderMessages();
        }

        log('Stream complete: ' + fullContent.substring(0, 50) + '...');
      } catch (error) {
        // Update assistant message with error
        messages[messages.length - 1].content = '‚ùå Error: ' + error.message;
        renderMessages();
        showError(error.message);
        log('Chat error: ' + error.message);
      } finally {
        sendBtn.disabled = false;
        messageInput.disabled = false;
        messageInput.focus();
      }
    }

    // Show error
    function showError(msg) {
      chatError.textContent = msg;
      chatError.style.display = 'block';
    }

    // Event listeners
    loginBtn.addEventListener('click', () => {
      log('Opening auth modal...');
      authSDK.openAuthModal();
    });

    logoutBtn.addEventListener('click', handleLogout);

    sendBtn.addEventListener('click', sendMessage);

    messageInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendMessage();
    });

    fileInput.addEventListener('change', (e) => {
      if (e.target.files && e.target.files.length > 0) {
        handleFileUpload(e.target.files);
      }
    });

    // Debug toggle
    debugToggle.addEventListener('click', () => {
      const isVisible = debugCard.style.display !== 'none';
      debugCard.style.display = isVisible ? 'none' : 'block';
      debugToggle.classList.toggle('active', !isVisible);
    });

    // Settings event listeners
    settingsBtn.addEventListener('click', openSettings);
    closeSettingsBtn.addEventListener('click', closeSettings);

    // Close modal when clicking outside
    settingsModal.addEventListener('click', (e) => {
      if (e.target === settingsModal) closeSettings();
    });

    // Save settings on change
    modelSelect.addEventListener('change', () => {
      saveSettings();
      updateModelInfo();
    });

    skipServerPromptToggle.addEventListener('change', saveSettings);

    systemPromptModal.addEventListener('input', saveSettings);

    // Chat persistence event listeners
    newChatBtn.addEventListener('click', handleNewChat);
    saveChatBtn.addEventListener('click', handleSaveChat);

    // Chat modal event listeners
    closeChatModalBtn.addEventListener('click', closeModal);
    chatModalCancelBtn.addEventListener('click', closeModal);
    chatModalSaveBtn.addEventListener('click', handleModalSave);
    chatModalSaveAsNewBtn.addEventListener('click', handleModalSaveAsNew);
    chatModalDiscardBtn.addEventListener('click', handleModalDiscard);
    chatModalDeleteBtn.addEventListener('click', handleModalDelete);

    // Close chat modal when clicking outside
    chatModal.addEventListener('click', (e) => {
      if (e.target === chatModal) closeModal();
    });

    // Handle Enter key in chat name input
    chatModalInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') handleModalSave();
    });

    // Sidebar toggle functions
    function openSidebar() {
      sidebar.classList.remove('collapsed');
      sidebarOpenBtn.classList.add('hidden');
      localStorage.setItem('hustle_sidebar_open', 'true');
    }

    function closeSidebar() {
      sidebar.classList.add('collapsed');
      sidebarOpenBtn.classList.remove('hidden');
      localStorage.setItem('hustle_sidebar_open', 'false');
    }

    function initSidebar() {
      const savedState = localStorage.getItem('hustle_sidebar_open');
      // Default to open if there are saved chats, closed otherwise
      const chats = getSavedChats();
      const hasSavedChats = Object.keys(chats).length > 0;

      if (savedState === 'true' || (savedState === null && hasSavedChats)) {
        openSidebar();
      } else {
        closeSidebar();
      }
    }

    // Sidebar event listeners
    sidebarOpenBtn.addEventListener('click', openSidebar);
    sidebarCloseBtn.addEventListener('click', closeSidebar);

    // Fullscreen toggle
    function toggleFullscreen() {
      document.body.classList.toggle('fullscreen-mode');
      const isFullscreen = document.body.classList.contains('fullscreen-mode');
      log('Fullscreen mode: ' + isFullscreen);
    }

    fullscreenBtn.addEventListener('click', toggleFullscreen);

    // =========================================================================
    // PAYG Management
    // =========================================================================
    let paygStatusData = null;
    let paygLoading = false;

    async function fetchPaygStatus() {
      if (!hustleClient || paygLoading) return;
      paygLoading = true;
      const section = document.getElementById('paygSection');
      section.textContent = '';
      const loadingP = document.createElement('p');
      loadingP.className = 'setting-description';
      loadingP.style.fontStyle = 'italic';
      loadingP.textContent = 'Loading billing status...';
      section.appendChild(loadingP);

      try {
        paygStatusData = await hustleClient.getPaygStatus();
        renderPaygUI();
      } catch (err) {
        section.textContent = '';
        const errP = document.createElement('p');
        errP.className = 'setting-description';
        errP.style.color = '#ef4444';
        errP.textContent = err.message;
        section.appendChild(errP);
      } finally {
        paygLoading = false;
      }
    }

    function renderPaygUI() {
      const section = document.getElementById('paygSection');
      if (!paygStatusData) return;

      const s = paygStatusData;
      const tokens = (s.available_tokens || ['SOL', 'SOL_USDC', 'HUSTLE', 'ETH', 'ETH_USDC', 'BASE_ETH', 'BASE_USDC']);
      const tokenOptions = tokens.map(t => '<option value="' + t + '"' + (t === s.payment_token ? ' selected' : '') + '>' + t + '</option>').join('');

      section.innerHTML = `
        <div class="setting-toggle">
          <span class="toggle-label">${s.enabled ? 'PAYG Enabled' : 'PAYG Disabled'}</span>
          <label class="toggle-switch">
            <input type="checkbox" id="paygToggle" ${s.enabled ? 'checked' : ''}>
            <span class="toggle-slider"></span>
          </label>
        </div>
        ${s.enabled ? `
          <div style="margin-top: 12px;">
            <label class="setting-description" style="display: block; margin-bottom: 4px;">Payment Token</label>
            <select id="paygTokenSelect" class="setting-select">${tokenOptions}</select>
          </div>
          <div style="margin-top: 8px;">
            <label class="setting-description" style="display: block; margin-bottom: 4px;">Payment Mode</label>
            <select id="paygModeSelect" class="setting-select">
              <option value="pay_per_request" ${s.mode === 'pay_per_request' ? 'selected' : ''}>Pay Per Request</option>
              <option value="debt_accumulation" ${s.mode === 'debt_accumulation' ? 'selected' : ''}>Debt Accumulation</option>
            </select>
          </div>
          <div class="payg-stat-grid">
            <div class="payg-stat-item"><div class="label">Chain</div><div class="value">${s.payment_chain || 'N/A'}</div></div>
            <div class="payg-stat-item"><div class="label">Total Debt</div><div class="value">$${(s.total_debt_usd || 0).toFixed(4)}</div></div>
            <div class="payg-stat-item"><div class="label">Total Paid</div><div class="value">$${(s.total_paid_usd || 0).toFixed(4)}</div></div>
            <div class="payg-stat-item"><div class="label">Debt Ceiling</div><div class="value">$${(s.debt_ceiling_usd || 0).toFixed(2)}</div></div>
            <div class="payg-stat-item"><div class="label">Pending</div><div class="value">${s.pending_charges || 0}</div></div>
            <div class="payg-stat-item"><div class="label">Status</div><div class="value">${s.is_blocked ? '<span class="payg-blocked">Blocked</span>' : 'Active'}</div></div>
          </div>
        ` : ''}
      `;

      // Attach event listeners
      document.getElementById('paygToggle').addEventListener('change', async (e) => {
        await configurePaygOption({ enabled: e.target.checked });
      });

      if (s.enabled) {
        document.getElementById('paygTokenSelect').addEventListener('change', async (e) => {
          await configurePaygOption({ payment_token: e.target.value });
        });
        document.getElementById('paygModeSelect').addEventListener('change', async (e) => {
          await configurePaygOption({ mode: e.target.value });
        });
      }
    }

    async function configurePaygOption(options) {
      if (!hustleClient) return;
      try {
        await hustleClient.configurePayg(options);
        log('PAYG configured: ' + JSON.stringify(options));
        await fetchPaygStatus();
      } catch (err) {
        log('PAYG error: ' + err.message);
      }
    }

    // Initialize on load
    log('Page loaded, initializing...');
    loadSettings();
    initSidebar();
    initAuth();
  </script>
</body>
</html>
